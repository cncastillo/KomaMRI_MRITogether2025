---
title: |
  Go with the Flow: \
  Using Extensible and Shareable Motion Phantoms in KomaMRI
author: "Carlos Castillo Passi"
date: 11 December 2025
toc: true
toc-depth: 1
toc-title: "Outline"
format:
    revealjs:
      date-format: "DD MMM YYYY"
      logo: presentation_files/figures/Stanford_logo.png
      css: presentation_files/styles/style.css
      bibliography: presentation_files/MyLibrary.bib
      csl: presentation_files/ieee.csl
      menu: true
      slide-number: c/t
      auto-play-media: true
      self-contained: true
      controls: true
title-slide-attributes:
  data-background-image: presentation_files/figures/ThesisCover.svg
  data-background-position: top
engine: julia
code-line-numbers: false
highlight-style: github-light
filters:
   - include-code-files
footer: "MRITogether 2025 - Carlos Castillo Passi"
execute-dir: project
julia:
  exeflags: 
    - "--project=@."
project:
  output-dir: _site      # where HTML + *_files go
  
---
# Presentation and material link

github.com/cncastillo/KomaMRI_MRITogether2025

<center>
{{< qrcode https://github.com/cncastillo/KomaMRI_MRITogether2025 width=300 height=300 >}}
</center>



# Motivation
## The Bloch equations
Describe the evolution of the magnetization:
$$
\frac{\mathrm{d}\vec{M}}{\mathrm{d}t} = \gamma \vec{M} \times \vec{B}(t) - \left(
\frac{M_x}{T_2},
\frac{M_y}{T_2},
\frac{M_z - M_0}{T_1}
\right)
$$

- $\vec{M}$ is the **measurement**, 
- $\vec{B}(t)$ is what we control with the **pulse sequence**, 
- $(M_0, T_1, T_2)$ are **tissue properties**.


## This equation is not really special, it is just an ODE

$$
\Large \frac{\mathrm{d}\vec{M}}{\mathrm{d}t} = \mathrm{bloch}(t, \vec{M})
$$

## … but this part makes it special!

![](presentation_files/figures/2DBloch.png){fig-align="center" width="90%"}

How can we solve this for 10,000 spins? 

(100x100)

## The number of ODEs explodes quite rapidly

![](presentation_files/figures/3DBloch.png){fig-align="center" width="90%"}

How can we solve this for 100,000,000 spins?

(460x460x460)

<!-- HOW ARE WE SIMULATING IT -->
# What's KomaMRI.jl?

## KomaMRI.jl[@castillo-passi_komamri_2023]
![](presentation_files/figures/koma-schematic.svg)

- Pulseq[@layton_pulseq_2017] as sequence definition.
- MRD[@inati_ismrm_2017] (previously ISMRMRD) as raw data format.
- **In this talk** we will mainly talk about the `.phantom`

## The Julia programming language[@bezanson_julia_2017]

:::{.columns}
::: {.column width="70%"}
- Similar syntax to MATLAB (commonly used in MRI community)
- Multi-threading support
- Excellent GPU support[@besard_rapid_2019; @besard_effective_2019]
- GUI support (PlotlyJS.jl and Blink.jl)
:::
::: {.column width="30%"}
![](presentation_files/figures/Julia.png)
:::
:::

## Operator-splitting method

:::{.columns}
::: {.column width="45%"}
![](presentation_files/figures/RF.svg){fig-align="center" width="100%"}
:::
::: {.column width="55%"}
- Continuous problem ($t$):
$$
\begin{align*}
\vec{M}_t &= ({{\color{red}A}} + {{\color{blue}B}})\vec{M}\\
\vec{m}_t &= {{\color{red}A}} \vec{m}\\
\vec{m}_t &= {{\color{blue}B}} \vec{m}\\
\end{align*}
$$
- Discrete problem ($t_n \rightarrow t_{n+1}$):
$$
\begin{align*}
\vec{m}^{n+1} &= \mathrm{e}^{{\mathrm{\color{red}A}} \Delta t} \vec{m}^{n}\\
\vec{m}^{n+1} &= \mathrm{e}^{{\mathrm{\color{blue}B}} \Delta t} \vec{m}^{n}\\
\vec{M}^{n+1} &= \mathrm{e}^{{\mathrm{\color{red}A}} \Delta t} \mathrm{e}^{\vec{\mathrm{\color{blue}B}} \Delta t} \vec{M}^{n}
\end{align*}
$$
:::
:::

## Graphical User Interface (GUI)
![](presentation_files/figures/ui-simulation.gif){fig-align="center"}

Results can be exported to `.mat`.

## GPU parallelization
![](presentation_files/figures/ParalelSpins.svg)

## Compatible with Pulseq[@layton_pulseq_2017]
```julia
seq = read_seq("spiral_3T.seq")
plot_seq(seq)
```
```{julia}
using KomaMRI
seq = read_seq("presentation_files/spiral.seq");
p = plot_seq(seq; height=500)
savefig(p, "presentation_files/figures/spiral.html")
nothing
```
:::{.columns}
::: {.column width="50%"}

```{.python include="presentation_files/spiral_snippet.seq"}
```
:::
::: {.column width="50%"}
```{=html}
<iframe src="presentation_files/figures/spiral.html" width="100%" height="520px"></iframe>
```
:::
:::

## Koma achieved excellent accuracy for all tested cases[@castillo-passi_komamri_2023]
![](presentation_files/figures/Comparison_JEMRIS.svg){fig-align="center"}

## Koma was significantly faster than MRiLab[@castillo-passi_komamri_2023]
|                | **CPU**                | **GPU1**              | **GPU2**              |
|----------------|------------------------|-----------------------|-----------------------|
| **Name**       | **Intel i7-1165G7**    | **GTX 1650 Ti**       | **RTX 2080 Ti**       |
| **JEMRIS**     | $\approx7\,\mathrm{min}$ | -                     | -                     |
| **MRiLab**     | $1.56\,\mathrm{s} \pm 0.07\,\mathrm{s}$ | $0.84\,\mathrm{s} \pm 0.02\,\mathrm{s}$   | $0.91\,\mathrm{s} \pm 0.02\,\mathrm{s}$   |
| **Koma**       | $1.82\,\mathrm{s} \pm 0.17\,\mathrm{s}$    | $0.32\,\mathrm{s} \pm 0.02\,\mathrm{s}$ | $0.15\,\mathrm{s} \pm 0.01\,\mathrm{s}$ |

<!-- WHAT'S NEW -->
# Updates since my previous talk (2023)

## Package separation (Boris Oróstica)

![](presentation_files/figures/koma-schema-subdirs.svg)

Only use what you need.

## Sub-packages have their own CI

![](presentation_files/figures/SubpackageCI.png){fig-align="center"}

- **KomaMRIBase**: Custom types and functions
- **KomaMRICore**: Simulation functions
- **KomaMRIFiles**: File I/O functions
- **KomaMRIPlots**: Plotting functions
- **KomaMRI**: User Interface

## Enhanced GPU support (Ryan Kierulf)

![](presentation_files/figures/BuildkiteKoma.png){fig-align="center"}

:::{.panel-tabset}
## CPU
```julia
using KomaMRI
obj = brain_phantom2D()
seq = PulseDesigner.EPI_example()
sys = Scanner()
raw = simulate(obj, seq, sys)
```
## NVIDIA
```julia
using KomaMRI, CUDA # Loads KomaMRICoreCUDAExt
obj = brain_phantom2D()
seq = PulseDesigner.EPI_example()
sys = Scanner()
raw = simulate(obj, seq, sys)
```
## AMD
```julia
using KomaMRI, AMDGPU # Loads KomaMRICoreAMDGPUExt
obj = brain_phantom2D()
seq = PulseDesigner.EPI_example()
sys = Scanner()
raw = simulate(obj, seq, sys)
```
## Apple silicon
```julia
using KomaMRI, Metal # Loads KomaMRICoreMetalExt
obj = brain_phantom2D()
seq = PulseDesigner.EPI_example()
sys = Scanner()
raw = simulate(obj, seq, sys)
```
## Intel
```julia
using KomaMRI, oneAPI # Loads KomaMRICoreoneAPIExt
obj = brain_phantom2D()
seq = PulseDesigner.EPI_example()
sys = Scanner()
raw = simulate(obj, seq, sys)
```
:::

## Buildkite CI and benchmark setup

![](presentation_files/figures/BuildkiteCI.png){fig-align="center"}

![](presentation_files/figures/BuildkiteBenchmarks.png){fig-align="center" width="65%"}

## Kernel-based GPU programming
We achieved **performance improvements** and **memory reductions**.

![](presentation_files/figures/KernelBasedGPU.png){fig-align="center"}


## Distributed computing
Koma is compatible with HPC and SLURM pipelines:

:::{.panel-tabset}
## Diagram
![](presentation_files/figures/KomamultiGPU.svg){fig-align="center" width="90%"}

## Julia
```julia
using Distributed, CUDA
addprocs(length(devices())) # One process per GPU
@everywhere begin
    using KomaMRI, CUDA
    sys = Scanner()
    seq = PulseDesigner.EPI_example()
    obj = brain_phantom2D()
    parts = kfoldperm(length(obj), nworkers()) # [1:10, 11:20, 21:30]
end
# Simulation
raw = @distributed (+) for i=1:nworkers()
    KomaMRICore.set_device!(i-1) #Sets device for this worker
    simulate(obj[parts[i]], seq, sys)
end
```
## SLURM
```bash
#!/bin/bash
#SBATCH --job-name KomaDistributed                 # Job name
#SBATCH -t 0-00:30                                 # Max runtime for job
#SBATCH -p batch                                   # Enter partition on which to run the job
#SBATCH --ntasks=1                                 # 1 task
#SBATCH --cpus-per-task=1                          # Request 1 CPU
#SBATCH --gpus=4                                   # Request 4 GPUs
#SBATCH -o /mnt/workspace/%u/slurm-out/%test.out   # Enter file path to write stdout to
#SBATCH -e /mnt/workspace/%u/slurm-out/%test.err   # Enter file path to write stderr to

module load julia/1.10.2
julia script.jl
```
:::

# New motion definition

## New motion def. (Pablo Villacorta) [@villacorta-aylagas_versatile_2025]

![](presentation_files/figures/GUI_aorta.mp4){fig-align="center" width="80%" loop="true"}

## Motion models
::: {.columns}
::: {.column width="40%"}
![](presentation_files/figures/MotionModelKoma.png)
:::
::: {.column width="60%"}
Case without motion:
```{julia}
#| echo: true
obj = brain_phantom2D()
obj.motion
```

Case with motion:
```{julia}
#| echo: true
obj = brain_phantom2D()
obj.motion = translate(1.0e-2, 0.0, 0.0)
```

Note that `translate` is a `Motion` and `Translate` is an `Action`.

:::
:::

## Export phantoms with motion
Let's export a generated phantom:
```{julia}
#| echo: true
obj = brain_phantom2D()
obj.motion = translate(1.0e-2, 0.0, 0.0)
write_phantom(obj, "presentation_files/brain_motion.phantom")
```

Then, you can **share** it and load it elsewhere:
```{julia}
#| echo: true
obj = read_phantom("presentation_files/brain_motion.phantom");
obj.motion
```
This works for **very complicated** phantoms as well!

## Phantom file structure

![](presentation_files/figures/ph-file-format.svg)

## Phantom file: actions

![](presentation_files/figures/ph-actions.svg)

## `Translate` action
::: {.columns}
::: {.column width="40%"}
```{julia}
#| echo: true
obj.motion = translate(
    1.0e-2, # x-displacement
    0.0,    # y-displacement
    0.0,    # z-displacement
    TimeRange(
      0.0,  # tstart
      1.0   # tend
    ), 
    AllSpins()
)
```

```{julia}
#| echo: true
obj.motion.action
```

:::
::: {.column width="60%"}
```{julia}
obj = brain_phantom2D()
obj.motion = translate(
    1.0e-2, # x-displacement
    0.0,    # y-displacement
    0.0,    # z-displacement
    TimeRange(0.0, 1.0), 
    AllSpins()
)
p = plot_phantom_map(obj, :T1; height=500, time_samples=5)
savefig(p, "presentation_files/figures/brain_translate.html")
nothing
```
<iframe src="presentation_files/figures/brain_translate.html" width="100%" height="520px"></iframe>

:::
:::

## `Rotate` action
::: {.columns}
::: {.column width="40%"}
```{julia}
#| echo: true
obj.motion = rotate(
    0.0,     # yaw
    0.0,     # pitch
    90.0,    # roll
    TimeRange(
      0.0,  # tstart
      1.0   # tend
    ), 
    AllSpins()
)
```


:::
::: {.column width="60%"}
```{julia}
obj = brain_phantom2D()
obj.motion = rotate(
    0.0,     # yaw
    0.0,     # pitch
    90.0,    # roll
    TimeRange(
      0.0,  # tstart
      1.0   # tend
    ), 
    AllSpins()
)
p = plot_phantom_map(obj, :T1; height=500, time_samples=5)
savefig(p, "presentation_files/figures/brain_rotate.html")
nothing
```
<iframe src="presentation_files/figures/brain_rotate.html" width="100%" height="520px"></iframe>

:::
:::

## `MotionList`: composable `Motion`'s
::: {.columns}
::: {.column width="40%"}
```julia
obj.motion = MotionList(
  translate(# Translation 1
    1.0e-2, # x-displacement
    0.0,    # y-displacement
    0.0,    # z-displacement
    TimeRange(0.0, 1.0), 
    AllSpins()
  ),
  translate(# Translation 2
    0.0,    # x-displacement
    1.0e-2, # y-displacement
    0.0,    # z-displacement
    TimeRange(1.0, 2.0), 
    AllSpins()
  ),
)
```
:::
::: {.column width="60%"}
```{julia}
obj = brain_phantom2D()
obj.motion = MotionList(
  translate(# Translation 1
    1.0e-2, # x-displacement
    0.0,    # y-displacement
    0.0,    # z-displacement
    TimeRange(0.0, 1.0), 
    AllSpins()
  ),
  translate(# Translation 2
    0.0,    # x-displacement
    1.0e-2, # y-displacement
    0.0,    # z-displacement
    TimeRange(1.0, 2.0), 
    AllSpins()
  ),
)
p = plot_phantom_map(obj, :T1; height=500)
savefig(p, "presentation_files/figures/brain.html")
nothing
```
<iframe src="presentation_files/figures/brain.html" width="100%" height="520px"></iframe>

:::
:::

## Uniformly-sampled `Path`'s

::: {.columns}
::: {.column width="40%"}
```julia
using Random
rng = MersenneTwister(1234)
dx = cumsum(randn(rng, Nspins, Nt); dims=2)
dy = cumsum(randn(rng, Nspins, Nt); dims=2)
dz = cumsum(randn(rng, Nspins, Nt); dims=2)
random_walk = path(
  dx, 
  dy, 
  dz, 
  TimeRange(0.0, T)
)
obj.motion = random_walk
```
:::
::: {.column width="60%"}
```{julia}
using Random
Nspins = 1_000
obj = Phantom(;
    x  = zeros(Nspins),
    T1 = ones(Nspins) * 1000e-3,
    T2 = ones(Nspins) * 100e-3,
)
D = 2e-9               # Diffusion Coefficient of water in m^2/s
T = 100e-3             # Duration of the motion
Nt = 100               # Number of time steps
Δt = T / (Nt - 1)      # Time sep
Δr = sqrt(2 * D * Δt)  # √ Mean square displacement
rng = MersenneTwister(1234) # Setting up the random seed
dx = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt)]; dims=2)
dy = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt)]; dims=2)
dz = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt)]; dims=2)
random_walk = path(dx, dy, dz, TimeRange(0.0, T))
obj.motion = random_walk
p = plot_phantom_map(obj, :T1; time_samples=Nt÷4, height=500)
savefig(p, "presentation_files/figures/random_walk.html")
nothing
```
<iframe src="presentation_files/figures/random_walk.html" width="100%" height="520px"></iframe>
:::
:::

## `flowpath` can use CFD-generated particle trajectories [@villacorta-aylagas_versatile_2025]

![](presentation_files/figures/FlowCFD.png){fig-align="center"}

- 5 million spins
- GPU NVIDIA Quadro RTX 4000 8 GB

## Faster simulations than CMRsim [@villacorta-aylagas_versatile_2025; @weine_cmrsim_2024]

KomaMRI 9 min vs CMRsim 39 min:

![](presentation_files/figures/CMRsimComparison.png){fig-align="center"}

## Distributed flow simulations across multiple GPUs [@villacorta-aylagas_versatile_2025]
![](presentation_files/figures/ParallelGPUCardiac.png){fig-align="center"}

- 7 million spins
- 4 x NVIDIA RTX A5000 24 GB

## So you can do a lot more stuff!
![](presentation_files/figures/CMROpenSourceFig2.svg){fig-align="center"}

## Flow and Acceleration Encoding

Submitted to ISMRM by Charles McGrath, Stanford University.

::: {.columns}
::: {.column width="50%"}
![](presentation_files/figures/charles_pipiline_figure_2.png)
SimVascular + GrOpt + CMRseq/Pulseq + KomaMRI = ❤️
:::
::: {.column width="50%"}
![](presentation_files/figures/charles_animation_velocity_figure_4.gif)
:::
:::

## You can accurately predict dynamics

![](presentation_files/figures/charles_aorta_figure_3.png){fig-align="center" width="80%"}

CFD velocity field - particle paths - simulated PC acquisition -  estimate velocity

# What's next?

## The perfectly imperfect scanner

Parallel imaging and high-order gradients (GIRF) [@zhang_data_stitching_2025].

![](presentation_files/figures/MultipleCoils.png){fig-align="center"}

## We have a PR that implements PI

![](presentation_files/figures/ParallelImagingKoma.png){fig-align="center"}

## More accurate and faster RF simulation

Submitted to Sedona/ISMRM by me, Stanford University.

::: {.columns}
::: {.column width="50%"}
![](presentation_files/figures/accurate_rf_magnus_figure_2.gif){fig-align="center" width="90%"}
:::
::: {.column width="50%"}
![](presentation_files/figures/magnus_rf_optimization_figure_6.gif){fig-align="center" width="100%"}
:::
:::

## Reverse-mode automatic differentiation

Submitted to ISMRM by Kareem Fareed, Stanford University.

![](presentation_files/figures/reverse_mode_ad_kareem_figure_4.png){fig-align="center" width="60%"}


<!-- CONCLUSIONS -->
# Conclusions
## KomaMRI.jl has a growing community

:::{.columns}
::: {.column width="50%"}
- Statistics:

<center>
![](https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FKomaMRICore&query=total_requests&label=Downloads){height=30px}
![](https://img.shields.io/github/stars/JuliaHealth/KomaMRI.jl?style=flat&label=Stars&color=blue){height=30px}
</center>

![](presentation_files/figures/KomaStars.png)

:::
::: {.column width="50%"}
![](presentation_files/figures/KomaWorldwide.png)

- 18 Collaborators:

![](https://contrib.rocks/image?repo=JuliaHealth/KomaMRI.jl){height=70px}
</a>

:::
:::

## Show support!

Star **KomaMRI.jl** on GitHub ⭐!
<center>
{{< qrcode https://github.com/JuliaHealth/KomaMRI.jl width="300" height="300">}}
</center>

Join JuliaHealth: `#health-and-medicine` on the Julia Slack.


## Acknowledgements {.smaller}
:::{.columns}
::: {.column width="40%"}
- Pablo Irarrázaval (UC)
- René Botnar (KCL/UC)
- Claudia Prieto (KCL/UC)
- Jacob Zelko (JuliaHealth)
- Ryan Kierulf (GSoC)
- Boris Orostica (iHEALTH, UC)
- Martín Stockle (iHEALTH, UC)
- Kareem Fareed (REU, Stanford)
- Dilum Aluthge (Julia)
- Tim Besard (Julia)
- and many more!
:::
::: {.column width="60%"}

![](presentation_files/figures/EnnisLab.png)

1. NIH R01 HL171515
2. American Physical Society DCOMP Travel Award
2. Google Summer of Code 2024
4. NumFocus small development grant
:::
:::

<!-- REFERENCES -->
## References {.scrollable}
::: {#refs}
:::
